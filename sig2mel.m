function [melspec, frate] = sig2mel(sig, varargin)
%SIG2MEL  Convert a time domain signal to mel-scale spectrogram.
%   SIG2MEL(X) returns the linear (not logarithmic) output from a
%   21-channel mel-scale filterbank applied to the magnitude spectrum
%   extracted from the 16 kHz time domain signal X, using
%   Hamming-windowed frames of 400 samples (25 ms) with a frame step
%   of 160 samples (10 ms), with a pre-emphasis filter H(z) = 1 -
%   0.97z^-1.
%
%   SIG2MEL(X, 'Option', Value, ...) can be used to override the
%   default values (in brackets) for the following parameters:
%
%   'Rate' [16000]: Sampling rate of the input signal, used only
%   for generating the mel filterbank.
%
%   'Preemph' [0.97]: Pre-emphasis filter coefficient.  For a
%   scalar value K, the filter [1 -K] will be used.  A vector will
%   be used as-is as a FIR filter.  The empty value [] will skip
%   the pre-emphasis filtering.
%
%   'Window' [400]: Window size, in samples.
%
%   'Step' [160]: Window step, in samples.
%
%   'WindowFunc' [@hamming]: Window function. Called with the
%   window size as a single argument.
%
%   'Channels' [determined based on sample rate]: Number of
%   channels in the mel filterbank. The default value for a 16 kHz
%   signal is 21.
%
%   'Filterbank' [generated by MELFBANK]: CxD custom filterbank
%   matrix, where C is the output dimensionality, and D must equal
%   ceil((W + 1) / 2), where W is the window size.
%
%   [M, F] = SIG2MEL(...) returns, in addition to the mel
%   spectrogram M, also the (unwindowed) signal frames F.
%
% Copyright (c) 2014, Kalle Palomaki and Heikki Kallasjoki
% All rights reserved.
% See the included README.txt for full license terms.


%% input arguments

p = inputParser;
p.FunctionName = 'sig2mel';
addParamValue(p, 'Rate', 16000);
addParamValue(p, 'Preemph', 0.97);
addParamValue(p, 'Window', 400);
addParamValue(p, 'Step', 160);
addParamValue(p, 'WindowFunc', @hamming);
addParamValue(p, 'Channels', []);
addParamValue(p, 'Filterbank', []);
parse(p, varargin{:});
arg = p.Results;
frate=arg.Step/arg.Rate;

%% pre-emphasis filtering

if ~isempty(arg.Preemph)
    pre = arg.Preemph;
    if isscalar(pre); pre = [1 -pre]; end
    sig = filter(pre, 1, sig);
end

%% windowing

[frames, ~] = buffer(sig, arg.Window, arg.Window-arg.Step, 'nodelay');

%% FFT analysis

dim = ceil((arg.Window + 1) / 2);
spec = fft(bsxfun(@times, frames, arg.WindowFunc(arg.Window)));
spec = abs(spec(1:dim, :));

%% mel-scale filterbank

if ~isempty(arg.Filterbank)
    mel = arg.Filterbank;
else
    mel = melfbank(dim, 'Channels', arg.Channels);
end

melspec = mel * spec;
